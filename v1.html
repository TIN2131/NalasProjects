<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bachata Basic — 3D Human (Slow Tempo)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0e13; color: #e9edf1; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #ui { position: absolute; inset: 0 auto auto 0; padding: 12px 14px; z-index: 10; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    #ui .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1); border-radius: 14px; padding: 10px 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.3); }
    label { font-size: 12px; opacity: 0.9; margin-right: 6px; }
    input[type="range"] { width: 180px; }
    button, select { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); color: #e9edf1; padding: 6px 10px; border-radius: 10px; cursor: pointer; }
    button:hover { background: rgba(255,255,255,0.12); }
    #hint { position: absolute; right: 12px; top: 12px; font-size: 12px; opacity: 0.8; }
    #footer { position: absolute; left: 12px; bottom: 10px; font-size: 12px; opacity: 0.7; }
    a { color: #a7d0ff; }
    #drop { position: absolute; inset: 0; border: 2px dashed rgba(255,255,255,0.18); border-radius: 16px; display: none; place-items: center; color: #cfe5ff; font-size: 14px; pointer-events: none; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="card">
      <button id="playBtn" title="Play / Pause">▶︎ Play</button>
      <label for="bpm">Tempo</label>
      <input id="bpm" type="range" min="40" max="120" step="1" value="68" />
      <span id="bpmVal">68 BPM</span>
    </div>
    <div class="card">
      <label for="role">Role</label>
      <select id="role">
        <option value="leader" selected>Leader (1 = step left)</option>
        <option value="follower">Follower (1 = step right)</option>
      </select>
      <label for="cam">Camera</label>
      <select id="cam">
        <option value="front" selected>Front</option>
        <option value="iso">Isometric</option>
        <option value="top">Top</option>
      </select>
      <button id="resetView">Reset View</button>
    </div>
    <div class="card">
      <button id="toggleFeet">Show foot trails</button>
      <button id="toggleGrid">Toggle grid</button>
    </div>
  </div>
  <div id="hint">Tip: You can also drag & drop a local <b>.glb</b>/<b>.gltf</b> character (rigged) onto this page.
  </div>
  <div id="drop">Drop GLB/GLTF here…</div>
  <div id="footer">Model defaults to Khronos <i>CesiumMan</i>. Animation is procedural (no mocap) to demo the bachata basic.
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.157/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/loaders/GLTFLoader.js";

    // ---- Scene setup ----
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e13);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(3.2, 2.0, 5.2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 7, 5);
    dir.castShadow = true;
    scene.add(dir);

    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(20, 10),
      new THREE.MeshStandardMaterial({ color: 0x0f141a, metalness: 0.0, roughness: 1.0 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Grid (toggleable)
    const grid = new THREE.GridHelper(20, 40, 0x334455, 0x223344);
    grid.position.y = 0.001;
    scene.add(grid);

    // Foot trails (small decals that show where the feet land)
    const footTrailGroup = new THREE.Group();
    scene.add(footTrailGroup);
    let trailsVisible = false;

    function addTrail(x, z, isLeft) {
      const g = new THREE.CircleGeometry(isLeft ? 0.08 : 0.08, 24);
      const m = new THREE.MeshBasicMaterial({ color: isLeft ? 0x77c3ff : 0xffa54b, transparent: true, opacity: 0.9 });
      const mesh = new THREE.Mesh(g, m);
      mesh.rotation.x = -Math.PI / 2;
      mesh.position.set(x, 0.002, z);
      footTrailGroup.add(mesh);
      if (!trailsVisible) footTrailGroup.visible = false;
    }

    // ---- Load a rigged human model ----
    const loader = new GLTFLoader();

    // Default model (public glTF sample, human figure). If that URL ever fails, drag & drop will still work.
    let modelUrl = "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMan/glTF/CesiumMan.gltf";

    let skinned, skeleton, bones = {}, baseBonePos = {};

    function mapBone(nameList) {
      for (const n of nameList) {
        const b = skeleton ? skeleton.getBoneByName(n) : scene.getObjectByName(n, true);
        if (b) return b;
      }
      return null;
    }

    function cacheBasePos(b) {
      if (!b) return;
      baseBonePos[b.name] = b.position.clone();
    }

    function findImportantBones() {
      bones.hips = mapBone(["Hips", "hips", "mixamorigHips", "mixamorig:Hips"]);
      bones.spine = mapBone(["Spine", "spine", "mixamorigSpine", "mixamorig:Spine"]);
      bones.leftUpLeg  = mapBone(["LeftUpLeg", "mixamorigLeftUpLeg", "mixamorig:LeftUpLeg", "LeftUpLeg_t"]);
      bones.leftLeg    = mapBone(["LeftLeg", "mixamorigLeftLeg", "mixamorig:LeftLeg"]);
      bones.leftFoot   = mapBone(["LeftFoot", "mixamorigLeftFoot", "mixamorig:LeftFoot"]);
      bones.rightUpLeg = mapBone(["RightUpLeg", "mixamorigRightUpLeg", "mixamorig:RightUpLeg", "RightUpLeg_t"]);
      bones.rightLeg   = mapBone(["RightLeg", "mixamorigRightLeg", "mixamorig:RightLeg"]);
      bones.rightFoot  = mapBone(["RightFoot", "mixamorigRightFoot", "mixamorig:RightFoot"]);

      // Cache base positions (for additive procedural offsets)
      for (const k in bones) cacheBasePos(bones[k]);
    }

    function loadModel(url) {
      return new Promise((resolve, reject) => {
        loader.load(url, (gltf) => {
          if (skinned) scene.remove(skinned);
          const root = gltf.scene;
          root.traverse(o => { o.castShadow = true; });
          scene.add(root);

          // Grab first SkinnedMesh's skeleton
          root.traverse(o => {
            if (o.isSkinnedMesh && !skeleton) {
              skinned = root;
              skeleton = o.skeleton;
            }
          });
          if (!skeleton) {
            console.warn("No skeleton found. The animation will be limited.");
          }
          findImportantBones();
          resolve();
        }, undefined, (err) => {
          reject(err);
        });
      });
    }

    // Initial load
    loadModel(modelUrl).catch(() => {
      alert("Could not load default model. Drag & drop a rigged GLB/GLTF onto the page.");
    });

    // Drag & drop support
    const drop = document.getElementById('drop');
    window.addEventListener('dragover', (e) => { e.preventDefault(); drop.style.display = 'grid'; });
    window.addEventListener('dragleave', () => { drop.style.display = 'none'; });
    window.addEventListener('drop', (e) => {
      e.preventDefault(); drop.style.display = 'none';
      const file = e.dataTransfer.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      loadModel(url);
    });

    // ---- Bachata basic: procedural animation ----
    // We drive foot bones and hips with small local offsets to illustrate side–together–side–tap.
    const TWO_PI = Math.PI * 2;
    const state = {
      playing: false,
      role: 'leader', // or 'follower'
      bpm: 68,        // beats per minute (1 count = 1 beat)
      showGrid: true,
    };

    function countPhase(timeSec) {
      // One count = 60/bpm seconds. An 8-count phrase duration:
      const beatDur = 60.0 / state.bpm;
      const total = 8 * beatDur;
      const t = (timeSec % total) / total; // 0..1 across 8 counts
      const countFloat = t * 8.0;          // 0..8
      const countIndex = Math.floor(countFloat); // 0..7
      const countT = countFloat - countIndex;    // 0..1 within count
      return { t, countIndex, countT };
    }

    function lerp(a, b, t) { return a + (b - a) * t; }

    // Step parameters (meters in model space)
    const STEP_SIDE = 0.24;      // lateral foot displacement on side steps
    const CLOSE_GAP = 0.12;      // how close the trailing foot comes
    const EXTRA_KICK = 0.04;     // small extra push on 3 & 7
    const TAP_LIFT = 0.03;       // small vertical on taps
    const HIP_SWAY = 0.06;       // hip side sway amplitude
    const HIP_BUMP = 0.025;      // vertical bump on taps

    // Keep a running time
    let tStart = performance.now() / 1000;

    // UI wiring
    const playBtn = document.getElementById('playBtn');
    const bpmSlider = document.getElementById('bpm');
    const bpmVal = document.getElementById('bpmVal');
    const roleSel = document.getElementById('role');
    const camSel = document.getElementById('cam');
    const resetBtn = document.getElementById('resetView');
    const toggleFeetBtn = document.getElementById('toggleFeet');
    const toggleGridBtn = document.getElementById('toggleGrid');

    playBtn.addEventListener('click', () => {
      state.playing = !state.playing;
      playBtn.textContent = state.playing ? '❚❚ Pause' : '▶︎ Play';
      if (state.playing) tStart = performance.now() / 1000 - 0.0001; // resume smoothly
    });
    bpmSlider.addEventListener('input', () => { state.bpm = +bpmSlider.value; bpmVal.textContent = `${state.bpm} BPM`; });
    roleSel.addEventListener('change', () => { state.role = roleSel.value; });
    camSel.addEventListener('change', () => setCamera(camSel.value));
    resetBtn.addEventListener('click', () => { controls.reset(); setCamera(camSel.value); });
    toggleFeetBtn.addEventListener('click', () => { trailsVisible = !trailsVisible; footTrailGroup.visible = trailsVisible; });
    toggleGridBtn.addEventListener('click', () => { grid.visible = !grid.visible; });

    function setCamera(mode) {
      if (mode === 'front') {
        camera.position.set(3.2, 2.0, 5.2);
        camera.lookAt(0, 1.1, 0);
      } else if (mode === 'iso') {
        camera.position.set(4.3, 3.3, 4.3);
        camera.lookAt(0, 1.1, 0);
      } else {
        camera.position.set(0.0, 8.0, 0.001);
        camera.lookAt(0, 1.0, 0);
      }
      controls.update();
    }

    setCamera('front');

    // Animate helper: get procedural offsets for each foot and hips at this phase
    function getOffsets(countIndex, cT, role) {
      // Leader: 1 step LEFT, 2 together (R), 3 left, 4 tap (R), 5 step RIGHT, 6 together (L), 7 right, 8 tap (L)
      // Follower mirrors left/right.
      const mirror = (role === 'follower') ? -1 : 1;

      // Smoothstep easing
      const ease = (x) => x * x * (3 - 2 * x);
      const move = (amt) => ease(cT) * amt;

      let L = { x: 0, y: 0 }, R = { x: 0, y: 0 }, H = { x: 0, y: 0 };

      switch (countIndex) {
        case 0: // 1 — lead side out
          L.x = mirror * -move(STEP_SIDE);
          H.x = mirror * -HIP_SWAY * cT; // sway into the step
          break;
        case 1: // 2 — together (trail in)
          L.x = mirror * -STEP_SIDE;
          R.x = mirror * -move(STEP_SIDE - CLOSE_GAP);
          H.x = mirror * -HIP_SWAY;
          break;
        case 2: // 3 — lead side a touch more
          L.x = mirror * -(STEP_SIDE + move(EXTRA_KICK));
          R.x = mirror * -(STEP_SIDE - CLOSE_GAP);
          H.x = mirror * -HIP_SWAY * (1 - 0.5 * cT);
          break;
        case 3: // 4 — tap (trail foot)
          L.x = mirror * -(STEP_SIDE + EXTRA_KICK);
          R.x = mirror * -(STEP_SIDE - CLOSE_GAP) + mirror * 0.06 * Math.sin(Math.PI * cT);
          R.y = TAP_LIFT * Math.sin(Math.PI * cT);
          H.x = mirror * -HIP_SWAY * (1 - cT);
          H.y = HIP_BUMP * Math.sin(Math.PI * cT);
          // Place a trail dot near tap end
          if (cT > 0.98) addTrail(L.x, 0, true), addTrail(R.x, 0, false);
          break;
        case 4: // 5 — step to the RIGHT (lead foot switches)
          R.x = mirror * move(STEP_SIDE);
          H.x = mirror * HIP_SWAY * cT;
          break;
        case 5: // 6 — together
          R.x = mirror * STEP_SIDE;
          L.x = mirror * move(STEP_SIDE - CLOSE_GAP);
          H.x = mirror * HIP_SWAY;
          break;
        case 6: // 7 — right a bit more
          R.x = mirror * (STEP_SIDE + move(EXTRA_KICK));
          L.x = mirror * (STEP_SIDE - CLOSE_GAP);
          H.x = mirror * HIP_SWAY * (1 - 0.5 * cT);
          break;
        case 7: // 8 — tap (other foot)
          R.x = mirror * (STEP_SIDE + EXTRA_KICK);
          L.x = mirror * (STEP_SIDE - CLOSE_GAP) - mirror * 0.06 * Math.sin(Math.PI * cT);
          L.y = TAP_LIFT * Math.sin(Math.PI * cT);
          H.x = mirror * HIP_SWAY * (1 - cT);
          H.y = HIP_BUMP * Math.sin(Math.PI * cT);
          if (cT > 0.98) addTrail(L.x, 0, true), addTrail(R.x, 0, false);
          break;
      }
      return { L, R, H };
    }

    // Render loop
    function tick() {
      requestAnimationFrame(tick);
      const now = performance.now() / 1000;
      controls.update();

      if (skeleton && state.playing) {
        const { countIndex, countT } = countPhase(now - tStart);
        const { L, R, H } = getOffsets(countIndex, countT, state.role);

        // Safeguard: some models may have different bone names
        const lF = bones.leftFoot, rF = bones.rightFoot, hips = bones.hips;

        if (lF && baseBonePos[lF.name]) {
          lF.position.x = baseBonePos[lF.name].x + L.x;
          lF.position.y = baseBonePos[lF.name].y + L.y;
        }
        if (rF && baseBonePos[rF.name]) {
          rF.position.x = baseBonePos[rF.name].x + R.x;
          rF.position.y = baseBonePos[rF.name].y + R.y;
        }
        if (hips && baseBonePos[hips.name]) {
          hips.position.x = baseBonePos[hips.name].x + H.x;
          hips.position.y = baseBonePos[hips.name].y + H.y;
        }
      }

      renderer.render(scene, camera);
    }

    tick();

    // Responsiveness
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
